package no.skatteetaten.fastsetting.formueinntekt.felles.typescriptdtotranslator.generator;

import no.skatteetaten.fastsetting.formueinntekt.felles.typescriptdtotranslator.generator.sample.*;
import org.junit.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class TypescriptDtoTest {

    @Test
    public void can_create_flat_object() {
        String typescript = new TypescriptDto().make(FlatSample.class);
        assertThat(typescript).isEqualTo("export interface FlatSample {\n"
                + "  string?: string,\n"
                + "  integer: number,\n"
                + "  bool: boolean\n"
                + "}\n");
    }
    @Test
    public void can_create_flat_object_with_namespace() {
        String typescript = new TypescriptDto()
            .withNamingStrategy(type -> new TypeName("sample", type.getSimpleName()))
            .make(FlatSample.class);
        assertThat(typescript).isEqualTo("export module sample {\n"
                + "  export interface FlatSample {\n"
                + "    string?: string,\n"
                + "    integer: number,\n"
                + "    bool: boolean\n"
                + "  }\n"
                + "}\n");
    }

    @Test
    public void can_create_nested_object() {
        String typescript = new TypescriptDto().make(NestedSample.class);
        assertThat(typescript).isEqualTo("export interface NestedSample {\n"
                + "  string?: string,\n"
                + "  integer: number,\n"
                + "  bool: boolean,\n"
                + "  sample?: FlatSample\n"
                + "}\n"
                + "export interface FlatSample {\n"
                + "  string?: string,\n"
                + "  integer: number,\n"
                + "  bool: boolean\n"
                + "}\n");
    }

    @Test
    public void can_create_nested_object_imploded() {
        String typescript = new TypescriptDto().withImplosion(Implosion.REGULAR).make(NestedSample.class);
        assertThat(typescript).isEqualTo("export interface NestedSample {\n"
            + "  string?: string,\n"
            + "  integer: number,\n"
            + "  bool: boolean,\n"
            + "  sample?: FlatSample\n"
            + "}\n"
            + "export interface FlatSample {\n"
            + "  string?: string,\n"
            + "  integer: number,\n"
            + "  bool: boolean\n"
            + "}\n"
            + "export interface Imploded_NestedSample {\n"
            + "  string?: string,\n"
            + "  integer: number,\n"
            + "  bool: boolean,\n"
            + "  sample_string?: string,\n"
            + "  sample_integer?: number,\n"
            + "  sample_bool?: boolean\n"
            + "}\n"
            + "export interface Imploded_FlatSample {\n"
            + "  string?: string,\n"
            + "  integer: number,\n"
            + "  bool: boolean\n"
            + "}\n"
            + "export function implode_NestedSample(input: NestedSample, output: any = { }): Imploded_NestedSample {\n"
            + "  output.string = input?.string;\n"
            + "  output.integer = input?.integer;\n"
            + "  output.bool = input?.bool;\n"
            + "  output.sample_string = input?.sample?.string;\n"
            + "  output.sample_integer = input?.sample?.integer;\n"
            + "  output.sample_bool = input?.sample?.bool;\n"
            + "  return output as Imploded_NestedSample;\n"
            + "}\n"
            + "export function implode_FlatSample(input: FlatSample, output: any = { }): Imploded_FlatSample {\n"
            + "  output.string = input?.string;\n"
            + "  output.integer = input?.integer;\n"
            + "  output.bool = input?.bool;\n"
            + "  return output as Imploded_FlatSample;\n"
            + "}\n"
            + "export function explode_NestedSample(input: Imploded_NestedSample, output: any = { }): NestedSample {\n"
            + "  if (input.string) {\n"
            + "    output.string = input.string;\n"
            + "  }\n"
            + "  if (input.integer) {\n"
            + "    output.integer = input.integer;\n"
            + "  }\n"
            + "  if (input.bool) {\n"
            + "    output.bool = input.bool;\n"
            + "  }\n"
            + "  if (input.sample_string) {\n"
            + "    if (output.sample == null) { output.sample = { }; }\n"
            + "    output.sample.string = input.sample_string;\n"
            + "  }\n"
            + "  if (input.sample_integer) {\n"
            + "    if (output.sample == null) { output.sample = { }; }\n"
            + "    output.sample.integer = input.sample_integer;\n"
            + "  }\n"
            + "  if (input.sample_bool) {\n"
            + "    if (output.sample == null) { output.sample = { }; }\n"
            + "    output.sample.bool = input.sample_bool;\n"
            + "  }\n"
            + "  return output as NestedSample;\n"
            + "}\n"
            + "export function explode_FlatSample(input: Imploded_FlatSample, output: any = { }): FlatSample {\n"
            + "  if (input.string) {\n"
            + "    output.string = input.string;\n"
            + "  }\n"
            + "  if (input.integer) {\n"
            + "    output.integer = input.integer;\n"
            + "  }\n"
            + "  if (input.bool) {\n"
            + "    output.bool = input.bool;\n"
            + "  }\n"
            + "  return output as FlatSample;\n"
            + "}\n");
    }

    @Test
    public void can_create_flat_object_array() {
        String typescript = new TypescriptDto().make(FlatArraySample.class);
        assertThat(typescript).isEqualTo("export interface FlatArraySample {\n"
                + "  string?: Array<string>,\n"
                + "  integer?: Array<number>,\n"
                + "  bool?: Array<boolean>\n"
                + "}\n");
    }

    @Test
    public void can_create_nested_object_array() {
        String typescript = new TypescriptDto().make(NestedArraySample.class);
        assertThat(typescript).isEqualTo("export interface NestedArraySample {\n"
                + "  string?: Array<string>,\n"
                + "  integer?: Array<number>,\n"
                + "  bool?: Array<boolean>,\n"
                + "  sample?: Array<FlatArraySample>\n"
                + "}\n"
                + "export interface FlatArraySample {\n"
                + "  string?: Array<string>,\n"
                + "  integer?: Array<number>,\n"
                + "  bool?: Array<boolean>\n"
                + "}\n");
    }

    @Test
    public void can_create_nested_object_imploded_array() {
        String typescript = new TypescriptDto().withImplosion(Implosion.REGULAR).make(NestedArraySample.class);
        assertThat(typescript).isEqualTo("export interface NestedArraySample {\n"
            + "  string?: Array<string>,\n"
            + "  integer?: Array<number>,\n"
            + "  bool?: Array<boolean>,\n"
            + "  sample?: Array<FlatArraySample>\n"
            + "}\n"
            + "export interface FlatArraySample {\n"
            + "  string?: Array<string>,\n"
            + "  integer?: Array<number>,\n"
            + "  bool?: Array<boolean>\n"
            + "}\n"
            + "export interface Imploded_NestedArraySample {\n"
            + "  string?: Array<string>,\n"
            + "  integer?: Array<number>,\n"
            + "  bool?: Array<boolean>,\n"
            + "  sample?: Array<Imploded_FlatArraySample>\n"
            + "}\n"
            + "export interface Imploded_FlatArraySample {\n"
            + "  string?: Array<string>,\n"
            + "  integer?: Array<number>,\n"
            + "  bool?: Array<boolean>\n"
            + "}\n"
            + "export function implode_NestedArraySample(input: NestedArraySample, output: any = { }): Imploded_NestedArraySample {\n"
            + "  output.string = input?.string;\n"
            + "  output.integer = input?.integer;\n"
            + "  output.bool = input?.bool;\n"
            + "  output.sample = input?.sample?.map((it) => implode_FlatArraySample(it));\n"
            + "  return output as Imploded_NestedArraySample;\n"
            + "}\n"
            + "export function implode_FlatArraySample(input: FlatArraySample, output: any = { }): Imploded_FlatArraySample {\n"
            + "  output.string = input?.string;\n"
            + "  output.integer = input?.integer;\n"
            + "  output.bool = input?.bool;\n"
            + "  return output as Imploded_FlatArraySample;\n"
            + "}\n"
            + "export function explode_NestedArraySample(input: Imploded_NestedArraySample, output: any = { }): NestedArraySample {\n"
            + "  if (input.string) {\n"
            + "    output.string = input.string;\n"
            + "  }\n"
            + "  if (input.integer) {\n"
            + "    output.integer = input.integer;\n"
            + "  }\n"
            + "  if (input.bool) {\n"
            + "    output.bool = input.bool;\n"
            + "  }\n"
            + "  if (input.sample) {\n"
            + "    output.sample = input.sample.map((it) => explode_FlatArraySample(it));\n"
            + "  }\n"
            + "  return output as NestedArraySample;\n"
            + "}\n"
            + "export function explode_FlatArraySample(input: Imploded_FlatArraySample, output: any = { }): FlatArraySample {\n"
            + "  if (input.string) {\n"
            + "    output.string = input.string;\n"
            + "  }\n"
            + "  if (input.integer) {\n"
            + "    output.integer = input.integer;\n"
            + "  }\n"
            + "  if (input.bool) {\n"
            + "    output.bool = input.bool;\n"
            + "  }\n"
            + "  return output as FlatArraySample;\n"
            + "}\n");
    }

    @Test
    public void can_create_nested_object_imploded_array_outed() {
        String typescript = new TypescriptDto().withImplosion(Implosion.REGULAR).make(OuterNestedArraySample.class);
        assertThat(typescript).isEqualTo("export interface OuterNestedArraySample {\n"
                + "  outer?: NestedArraySample\n"
                + "}\n"
                + "export interface NestedArraySample {\n"
                + "  string?: Array<string>,\n"
                + "  integer?: Array<number>,\n"
                + "  bool?: Array<boolean>,\n"
                + "  sample?: Array<FlatArraySample>\n"
                + "}\n"
                + "export interface FlatArraySample {\n"
                + "  string?: Array<string>,\n"
                + "  integer?: Array<number>,\n"
                + "  bool?: Array<boolean>\n"
                + "}\n"
                + "export interface Imploded_OuterNestedArraySample {\n"
                + "  outer_string?: Array<string>,\n"
                + "  outer_integer?: Array<number>,\n"
                + "  outer_bool?: Array<boolean>,\n"
                + "  outer_sample?: Array<Imploded_FlatArraySample>\n"
                + "}\n"
                + "export interface Imploded_NestedArraySample {\n"
                + "  string?: Array<string>,\n"
                + "  integer?: Array<number>,\n"
                + "  bool?: Array<boolean>,\n"
                + "  sample?: Array<Imploded_FlatArraySample>\n"
                + "}\n"
                + "export interface Imploded_FlatArraySample {\n"
                + "  string?: Array<string>,\n"
                + "  integer?: Array<number>,\n"
                + "  bool?: Array<boolean>\n"
                + "}\n"
                + "export function implode_OuterNestedArraySample(input: OuterNestedArraySample, output: any = { }): Imploded_OuterNestedArraySample {\n"
                + "  output.outer_string = input?.outer?.string;\n"
                + "  output.outer_integer = input?.outer?.integer;\n"
                + "  output.outer_bool = input?.outer?.bool;\n"
                + "  output.outer_sample = input?.outer?.sample?.map((it) => implode_FlatArraySample(it));\n"
                + "  return output as Imploded_OuterNestedArraySample;\n"
                + "}\n"
                + "export function implode_NestedArraySample(input: NestedArraySample, output: any = { }): Imploded_NestedArraySample {\n"
                + "  output.string = input?.string;\n"
                + "  output.integer = input?.integer;\n"
                + "  output.bool = input?.bool;\n"
                + "  output.sample = input?.sample?.map((it) => implode_FlatArraySample(it));\n"
                + "  return output as Imploded_NestedArraySample;\n"
                + "}\n"
                + "export function implode_FlatArraySample(input: FlatArraySample, output: any = { }): Imploded_FlatArraySample {\n"
                + "  output.string = input?.string;\n"
                + "  output.integer = input?.integer;\n"
                + "  output.bool = input?.bool;\n"
                + "  return output as Imploded_FlatArraySample;\n"
                + "}\n"
                + "export function explode_OuterNestedArraySample(input: Imploded_OuterNestedArraySample, output: any = { }): OuterNestedArraySample {\n"
                + "  if (input.outer_string) {\n"
                + "    if (output.outer == null) { output.outer = { }; }\n"
                + "    output.outer.string = input.outer_string;\n"
                + "  }\n"
                + "  if (input.outer_integer) {\n"
                + "    if (output.outer == null) { output.outer = { }; }\n"
                + "    output.outer.integer = input.outer_integer;\n"
                + "  }\n"
                + "  if (input.outer_bool) {\n"
                + "    if (output.outer == null) { output.outer = { }; }\n"
                + "    output.outer.bool = input.outer_bool;\n"
                + "  }\n"
                + "  if (input.outer_sample) {\n"
                + "    if (output.outer == null) { output.outer = { }; }\n"
                + "    output.outer.sample = input.outer_sample.map((it) => explode_FlatArraySample(it));\n"
                + "  }\n"
                + "  return output as OuterNestedArraySample;\n"
                + "}\n"
                + "export function explode_NestedArraySample(input: Imploded_NestedArraySample, output: any = { }): NestedArraySample {\n"
                + "  if (input.string) {\n"
                + "    output.string = input.string;\n"
                + "  }\n"
                + "  if (input.integer) {\n"
                + "    output.integer = input.integer;\n"
                + "  }\n"
                + "  if (input.bool) {\n"
                + "    output.bool = input.bool;\n"
                + "  }\n"
                + "  if (input.sample) {\n"
                + "    output.sample = input.sample.map((it) => explode_FlatArraySample(it));\n"
                + "  }\n"
                + "  return output as NestedArraySample;\n"
                + "}\n"
                + "export function explode_FlatArraySample(input: Imploded_FlatArraySample, output: any = { }): FlatArraySample {\n"
                + "  if (input.string) {\n"
                + "    output.string = input.string;\n"
                + "  }\n"
                + "  if (input.integer) {\n"
                + "    output.integer = input.integer;\n"
                + "  }\n"
                + "  if (input.bool) {\n"
                + "    output.bool = input.bool;\n"
                + "  }\n"
                + "  return output as FlatArraySample;\n"
                + "}\n");
    }

    @Test
    public void can_create_enum() {
        String typescript = new TypescriptDto().make(EnumSample.class);
        assertThat(typescript).isEqualTo("export interface EnumSample {\n"
                + "  sample?: SampleEnum\n"
                + "}\n"
                + "export enum SampleEnum {\n"
                + "  FOO = \"FOO\",\n"
                + "  BAR = \"BAR\"\n"
                + "}\n");
    }
}
